//
//  GTFSParser.swift
//  sptransAPI
//
//  Created by resource on 8/2/16.
//  Copyright Â© 2016 bienemann. All rights reserved.
//

import Foundation
import Alamofire
import RealmSwift
import CSVImporter

class GTFSParser {
    
    static let sharedInstance = GTFSParser()
    
    func parseFromURL(urlString : String, completion: Array<Dictionary<String, AnyObject>> -> Void){
        Alamofire.request(.GET, urlString).responseData { (response) in
            self.GTFSFileToArray(response.data!, completion: { (dataArray) in
                if dataArray != nil{
                    completion(dataArray!)
                }else{
                    //to-do: tratar erro
                }
            })
        }
    }
    
    func parseCSV(filePath : String, completion: (Array<Dictionary<String, AnyObject>>?) -> Void){
        
        
        
        let importer = CSVImporter<[String: String]>(path: filePath)
        importer.startImportingRecords(structure: { (headerValues) -> Void in
            
            print(headerValues) // => ["firstName", "lastName"]
            
        }) { $0 }.onFail({ 
            print("fail")
        }) .onFinish { importedRecords in
            
            for record in importedRecords {
                print(record) // => e.g. ["firstName": "Harry", "lastName": "Potter"]
                print(record["firstName"]) // prints "Harry" on first, "Hermione" on second run
                print(record["lastName"]) // prints "Potter" on first, "Granger" on second run
            }
            
        }
        
        NSFileManager.defaultManager().fileExistsAtPath("file:///Users/Aya/Library/Developer/CoreSimulator/Devices/C0616519-F70C-4D24-8E1F-CE2F984FCED4/data/Containers/Data/Application/84464528-D97A-452C-B924-426E9A593F72/Documents/fare_attributes.txt")
        
        
//        importer.startImportingRecords(structure: { (headerValues) in
//            print(headerValues)
//        }) { $0 }.onFinish({ (importedRecords) in
//            print(importedRecords)
//        })
    }
    
    func GTFSFileToArray(data: NSData, completion: (Array<Dictionary<String, AnyObject>>?) -> Void){
        //Start parsing in a background thread
        dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0)) {
            
            //return nil if we can't get a UTF-8 string from the data
            guard let dataString = NSString(data: data, encoding: NSUTF8StringEncoding) else {
                dispatch_async(dispatch_get_main_queue(), { 
                    completion(nil)
                })
                return
            }
            
            //break file into lines
            var lines : Array<String> = dataString.componentsSeparatedByCharactersInSet(.newlineCharacterSet())
            lines = lines.filter { (line) -> Bool in
                //remove empty lines (generated by \n\r line breaks)
                return line.characters.count > 0
            }
            
            //separate and 'clean' first line for indexing values
            var indexLine : Array<String> = lines.first!.componentsSeparatedByString(",")
            for (index,component) in indexLine.enumerate() {
                indexLine[index] = component.stringByReplacingOccurrencesOfString("\"", withString: "")
            }
            lines.removeFirst()
            
            var parsedArray : Array<Dictionary<String, AnyObject>> = Array()
            
            //parse each line in a key/value dictionary
            for line in lines {
                let elements : Array<String> = line.componentsSeparatedByString(",")
                var lineDict : Dictionary<String, AnyObject> = Dictionary()
                
                for (index, var element) in elements.enumerate() {
                    element = element.stringByReplacingOccurrencesOfString("\"", withString: "")
                    lineDict.updateValue(element, forKey: indexLine[index])
                }
                
                parsedArray.append(lineDict)
            }
            
            completion(parsedArray)
        }
    }
    
    func parse<T:Object>(url: String, className: T.Type){
        self.parseFromURL(url) { (resultsArray) in
            let realm = try! Realm()
            for object in resultsArray{
                let newEntry = className.init()
                for (key, value) in object{
                    newEntry.setValue(value, forKey: key)
                }
                try! realm.write {
                    realm.add(newEntry)
                }
            }
        }
    }
    
    
}
